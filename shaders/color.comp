#version 460 
    
#define WALL(index) fluid_buffer[OFFSET_WALL + index]
#define VEL_H(index) fluid_buffer[OFFSET_VEL_H + index]
#define VEL_H_2(index) fluid_buffer[OFFSET_VEL_H_2 + index]
#define VEL_V(index) fluid_buffer[OFFSET_VEL_V + index]
#define VEL_V_2(index) fluid_buffer[OFFSET_VEL_V_2 + index]
#define PRESSURE(index) fluid_buffer[OFFSET_PRESSURE + index]
#define COLOR(index) fluid_buffer[OFFSET_COLOR + index]
#define COLOR_2(index) fluid_buffer[OFFSET_COLOR_2 + index]
 
layout(push_constant) uniform push_constants {
    uint[4] sim_state;
    float[4] fluid_constants;
};
layout(std430, binding = 0) buffer storage_buffer {
    float[] fluid_buffer;
};
layout(binding = 1, rgba8) uniform writeonly image2D fluid_image;
layout(local_size_x = 16, local_size_y = 16) in;
       

float intersection(vec2 a, vec2 b, vec2 c, vec2 d) {
    float div = d.x * b.y - d.y * b.x; 
    if (div == 0.0)
      return 0.0;
    return ((c.y - a.y) * d.x - (c.x - a.x) * d.y) / div;
}
    
vec2 reflect_custom(vec2 a, vec2 b) {
    return 2 * (dot(a, b) / dot(b, b)) * b - a;  
}    
    
void main() {
    uint width = sim_state[0];
    uint height = sim_state[1];
    uint x = gl_GlobalInvocationID.x + 1;
    uint y = gl_GlobalInvocationID.y + 1;
    if(x >= width - 1 || y >= height - 1)
        return;
    uint sim_size = width * height;
    uint index = y * width + x;
        
    uint OFFSET_WALL = 0;
    uint OFFSET_VEL_H = 1 * sim_size;
    uint OFFSET_VEL_H_2 = 2 * sim_size;
    uint OFFSET_VEL_V = 3 * sim_size;
    uint OFFSET_VEL_V_2 = 4 * sim_size;
    uint OFFSET_PRESSURE = 5 * sim_size;
    uint OFFSET_COLOR = 6 * sim_size;
    uint OFFSET_COLOR_2 = 9 * sim_size;
    if(sim_state[2] == 0) {    
        OFFSET_VEL_H = 2 * sim_size;
        OFFSET_VEL_H_2 = 1 * sim_size;
        OFFSET_VEL_V = 4 * sim_size;
        OFFSET_VEL_V_2 = 3 * sim_size;
        OFFSET_COLOR = 9 * sim_size;
        OFFSET_COLOR_2 = 6 * sim_size;
    }

    float frame_time = fluid_constants[2];
    float multiply_h = 2.0 / (WALL(index - 1) + WALL(index + 1));
    float vel_h = VEL_H_2(index) * WALL(index - 1) + VEL_H_2(index + 1) * WALL(index + 1);
    float multiply_v = 2.0 / (WALL(index - width) + WALL(index + width));
    float vel_v = VEL_V_2(index) * WALL(index - width) + VEL_V_2(index + width) * WALL(index + width);
    vec2 cell_vec = vec2(vel_h * multiply_h, vel_v * multiply_v) * -frame_time; 
    vec2 cell_loc = vec2(float(x) + 0.5, float(y) + 0.5);
    //trace back and reflect on walls
    while(true) {
      float factors[4];
      factors[0] = intersection(cell_loc, cell_vec, vec2(0.0, 1.0), vec2(1.0, 0.0)); 
      factors[1] = intersection(cell_loc, cell_vec, vec2(1.0, 0.0), vec2(0.0, 1.0));
      factors[2] = intersection(cell_loc, cell_vec, vec2(0.0, height - 1.0f), vec2(1.0, 0.0));     
      factors[3] = intersection(cell_loc, cell_vec, vec2(width - 1.0f, 0.0), vec2(0.0, 1.0));
      float smallest_value = 3.0e20;
      int smallest_index = -1;
      for (uint i = 0; i < 4; i++) {
        if (factors[i] > 1.0 || factors[i] <= 0.0 || factors[i] > smallest_value)
          continue;
        smallest_value = factors[i];
        smallest_index = int(i);
      }
      if(smallest_index == -1) {   
        cell_loc += cell_vec;
        break;
      }
      cell_loc += cell_vec * smallest_value * 0.9999;        
      if (smallest_index == 0 || smallest_index == 2) {  
        cell_vec = reflect_custom(cell_vec, vec2(1.0, 0.0)) * (1.0 - smallest_value);
      } else if (smallest_index == 1 || smallest_index == 3) {
        cell_vec = reflect_custom(cell_vec, vec2(0.0, 1.0)) * (1.0 - smallest_value);
      }
    }  
    //interpolate and advect color
    cell_loc -= vec2(0.5 , 0.5);
    uint x_traced = uint(cell_loc.x);
    uint y_traced = uint(cell_loc.y);
    float x_inner = cell_loc.x - float(x_traced);
    float y_inner = cell_loc.y - float(y_traced);
    uint index_1 = (y_traced * width + x_traced);
    uint index_2 = (y_traced * width + (x_traced + 1));      
    uint index_3 = ((y_traced + 1) * width + (x_traced + 1));
    uint index_4 = ((y_traced + 1) * width + x_traced);
    float weight_1 = (1.0 - x_inner) * (1.0 - y_inner) * WALL(index_1);
    float weight_2 = x_inner * (1.0 - y_inner) * WALL(index_2);
    float weight_3 = x_inner * y_inner * WALL(index_3);
    float weight_4 = (1.0 - x_inner) * y_inner * WALL(index_4);
    float wall_add = 1.0 / (weight_1 + weight_2 + weight_3 + weight_4);
    for(int i = 0; i < 3; i++) {        
      COLOR_2(index * 3 + i) = wall_add * 
        (COLOR(index_1 * 3 + i) * weight_1 + 
        COLOR(index_2 * 3 + i) * weight_2 + 
        COLOR(index_3 * 3 + i) * weight_3 + 
        COLOR(index_4 * 3 + i) * weight_4);
    }    
    //copy image
    vec4 color = vec4(COLOR_2(index * 3), COLOR_2(index * 3 + 1), COLOR_2(index * 3 + 2), 1.0);
    imageStore(fluid_image, ivec2(gl_GlobalInvocationID.xy), color);
}
