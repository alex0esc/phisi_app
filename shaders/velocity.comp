#version 460  
#extension GL_ARB_shading_language_include : require
#include "functions.glsl"    

#define WALL(index) fluid_buffer[OFFSET_WALL + index]
#define VEL_H(index) fluid_buffer[OFFSET_VEL_H + index]
#define VEL_H_2(index) fluid_buffer[OFFSET_VEL_H_2 + index]
#define VEL_V(index) fluid_buffer[OFFSET_VEL_V + index]
#define VEL_V_2(index) fluid_buffer[OFFSET_VEL_V_2 + index]
#define PRESSURE(index) fluid_buffer[OFFSET_PRESSURE + index]
#define COLOR(index) fluid_buffer[OFFSET_COLOR + index]
#define COLOR_2(index) fluid_buffer[OFFSET_COLOR_2 + index]
 
layout(push_constant) uniform push_constants {
    uint[4] sim_state;
    float[4] fluid_constants;
};
layout(std430, binding = 0) buffer storage_buffer {
    float[] fluid_buffer;
};
layout(binding = 1, rgba8) uniform writeonly image2D fluid_image;
layout(local_size_x = 16, local_size_y = 16) in;
    

void main() {
    uint width = sim_state[0];
    uint height = sim_state[1];
    uint x = gl_GlobalInvocationID.x + 1;
    uint y = gl_GlobalInvocationID.y + 1;
    if(x >= width - 1 || y >= height - 1)
        return;
    uint sim_size = width * height;
    uint index = y * width + x;
        
    uint OFFSET_WALL = 0;
    uint OFFSET_VEL_H = 1 * sim_size;
    uint OFFSET_VEL_H_2 = 2 * sim_size;
    uint OFFSET_VEL_V = 3 * sim_size;
    uint OFFSET_VEL_V_2 = 4 * sim_size;
    uint OFFSET_PRESSURE = 5 * sim_size;
    uint OFFSET_COLOR = 6 * sim_size;
    uint OFFSET_COLOR_2 = 9 * sim_size;
    if(sim_state[2] == 0) {    
        OFFSET_VEL_H = 2 * sim_size;
        OFFSET_VEL_H_2 = 1 * sim_size;
        OFFSET_VEL_V = 4 * sim_size;
        OFFSET_VEL_V_2 = 3 * sim_size;
        OFFSET_COLOR = 9 * sim_size;
        OFFSET_COLOR_2 = 6 * sim_size;
    }
    
    float frame_time = fluid_constants[2];
    
    //vertical velocity
    if (y > 1) {
        float vel_h = (VEL_H(index) + VEL_H(index + 1) + VEL_H(index - width) + VEL_H(index - width + 1)) / 4.0;
        vec2 cell_vec = vec2(vel_h, VEL_V(index)) * -frame_time;
        vec2 cell_loc = vec2(float(x) + 0.5f, float(y));
        
        reflect_in_box(width, height, cell_vec, cell_loc);
          
        //interpolate and calculate velocity
        vec2 cell_loc_0 = cell_loc - vec2(0.5, 0.0);
        uint x_traced = uint(cell_loc_0.x);
        uint y_traced = uint(cell_loc_0.y);
        float x_inner = cell_loc_0.x - float(x_traced);
        float y_inner = cell_loc_0.y - float(y_traced);
        uint index_1 = (y_traced * width + x_traced);
        uint index_2 = (y_traced * width + (x_traced + 1));      
        uint index_3 = ((y_traced + 1) * width + (x_traced + 1));
        uint index_4 = ((y_traced + 1) * width + x_traced);
        float weight_1 = (1.0 - x_inner) * (1.0 - y_inner) * WALL(index_1);
        float weight_2 = x_inner * (1.0 - y_inner) * WALL(index_2);
        float weight_3 = x_inner * y_inner * WALL(index_3);
        float weight_4 = (1.0 - x_inner) * y_inner * WALL(index_4);
        float wall_add = 1.0 / (weight_1 + weight_2 + weight_3 + weight_4);
        VEL_V_2(index) = wall_add *
          (VEL_V(index_1) * weight_1 + 
          VEL_V(index_2) * weight_2 + 
          VEL_V(index_3) * weight_3 + 
          VEL_V(index_4) * weight_4);
    }

    //horizontal velocity
    if (x > 1) {   
        float vel_v = (VEL_V(index - 1) + VEL_V(index) + VEL_V(index + width) + VEL_V(index + width - 1)) / 4.0;
        vec2 cell_vec = vec2(VEL_H(index), vel_v) * -frame_time;
        vec2 cell_loc = vec2(float(x), float(y) + 0.5f);
        
        reflect_in_box(width, height, cell_vec, cell_loc);  
        
        //interpolate and calculate velocity
        vec2 cell_loc_0 = cell_loc - vec2(0.0, 0.5);
        uint x_traced = uint(cell_loc_0.x);
        uint y_traced = uint(cell_loc_0.y);
        float x_inner = cell_loc_0.x - float(x_traced);
        float y_inner = cell_loc_0.y - float(y_traced);
        uint index_1 = (y_traced * width + x_traced);
        uint index_2 = (y_traced * width + (x_traced + 1));      
        uint index_3 = ((y_traced + 1) * width + (x_traced + 1));
        uint index_4 = ((y_traced + 1) * width + x_traced);
        float weight_1 = (1.0 - x_inner) * (1.0 - y_inner) * WALL(index_1);
        float weight_2 = x_inner * (1.0 - y_inner) * WALL(index_2);
        float weight_3 = x_inner * y_inner * WALL(index_3);
        float weight_4 = (1.0 - x_inner) * y_inner * WALL(index_4);
        float wall_add = 1.0 / (weight_1 + weight_2 + weight_3 + weight_4);
        VEL_H_2(index) = wall_add *
          (VEL_H(index_1) * weight_1 + 
          VEL_H(index_2) * weight_2 + 
          VEL_H(index_3) * weight_3 + 
          VEL_H(index_4) * weight_4);
    }
}
